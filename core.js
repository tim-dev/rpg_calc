// Generated by CoffeeScript 1.6.3
(function() {
  var Entity, Weapon, app, make_entity, roll_dice, uuid, _roll_die;

  uuid = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r, v;
      r = Math.random() * 16 | 0;
      v = c === 'x' ? r : r & 0x3 || 0x8;
      return v.toString(16);
    });
  };

  roll_dice = function(roll_string) {
    /*
    Example roll strings:
    1d6
    1d8 + 8
    1d8 + 2d4 + 3
    */

    var dice, dice_parts, roll, roll_part, roll_parts, _i, _len;
    dice_parts = roll_string.split(/\ *\+\ */g);
    roll = 0;
    roll_parts = [];
    for (_i = 0, _len = dice_parts.length; _i < _len; _i++) {
      dice = dice_parts[_i];
      roll_part = _roll_die(dice);
      roll_parts.push("" + dice + " - " + roll_part);
      roll += roll_part;
    }
    console.log("Rolled a " + roll_string + ", parts were " + roll_parts);
    return roll;
  };

  _roll_die = function(dice) {
    var die, i, num, roll, total, _ref;
    if (typeof dice === "int") {
      return dice;
    }
    if (dice.indexOf('d') === -1) {
      return parseInt(dice);
    }
    _ref = dice.split("d"), num = _ref[0], die = _ref[1];
    num = parseInt(num);
    die = parseInt(die);
    i = total = 0;
    while (i < num) {
      roll = Math.ceil(Math.random() * die);
      total += roll;
      i++;
    }
    return total;
  };

  Entity = (function() {
    function Entity(options) {
      var k, v,
        _this = this;
      if (options == null) {
        options = {};
      }
      for (k in options) {
        v = options[k];
        this[k] = v;
      }
      this.name || (this.name = "New entity");
      this.cur_hit_points || (this.cur_hit_points = this.max_hit_points || 10);
      this.max_hit_points || (this.max_hit_points = this.cur_hit_points);
      this.armor_class || (this.armor_class = 10);
      this.armor_reduction || (this.armor_reduction = 0);
      this.weapons || (this.weapons = []);
      this.weapons = this.weapons.map(function(w) {
        return new Weapon(w);
      });
      this.checks || (this.checks = {});
      this.adding = true;
      setTimeout(function() {
        return _this.adding = false;
      }, 1000);
    }

    Entity.prototype.damage = function(damage) {
      if (damage == null) {
        damage = 0;
      }
      return this.cur_hit_points -= damage < 0 ? 0 : damage;
    };

    Entity.prototype.heal = function(healing) {
      if (healing == null) {
        healing = 0;
      }
      return this.cur_hit_points += healing < 0 ? 0 : healing;
    };

    return Entity;

  })();

  Weapon = (function() {
    function Weapon(options) {
      var k, v;
      if (options == null) {
        options = {};
      }
      for (k in options) {
        v = options[k];
        this[k] = v;
      }
    }

    Weapon.prototype.attack = function(defender, options) {
      var base_damage, bonus, degree, given_damage, hit, roll;
      if (options == null) {
        options = {};
      }
      if (options.roll) {
        roll = parseInt(options.roll);
        bonus = /\ *[+-]\d(?!n)/.exec(this.hit_dice);
        if (bonus) {
          roll += parseInt(bonus[0]);
        }
      } else {
        roll = roll_dice(this.hit_dice);
      }
      roll += options.hit_modifier || 0;
      hit = roll > defender.armor_class;
      if (!hit) {
        return {
          hit: hit,
          roll: roll
        };
      }
      degree = 1;
      if (options.use_degree) {
        degree = Math.ceil((roll - defender.armor_class) / 5);
      }
      base_damage = roll_dice(this.damage);
      given_damage = (degree * base_damage) - defender.armor_reduction;
      defender.damage(given_damage);
      return {
        hit: hit,
        roll: roll,
        degree: degree,
        base_damage: base_damage,
        given_damage: given_damage
      };
    };

    return Weapon;

  })();

  make_entity = function(options) {
    if (options == null) {
      options = {};
    }
    options.uuid || (options.uuid = uuid());
    return new Entity(options);
  };

  app = angular.module('app', []).directive('entity', function() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        entity: "="
      },
      templateUrl: "entity.html",
      controller: function($scope, $element, $attrs) {
        $($element).draggable({
          distance: 10,
          delay: 100,
          zIndex: 100
        }).on("click", function() {
          return $scope.$apply(function(scope) {
            return scope.$parent.set_combatant(scope.entity);
          });
        });
        return $scope.hit_point_color = function() {
          var hp;
          hp = $scope.entity.cur_hit_points;
          if (hp < 1) {
            return "red";
          } else if (hp < 0.5 * $scope.entity.max_hit_points) {
            return "yellow";
          }
          return "";
        };
      }
    };
  }).directive('entitybasics', function() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        entity: "="
      },
      templateUrl: "entity_basics.html"
    };
  }).directive('ddentity', function() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        entity: "="
      },
      templateUrl: "ddentity.html",
      controller: function($scope, $element, $attrs) {
        $scope.add_weapon = function() {
          return $scope.entity.weapons.push(new Weapon());
        };
        return $scope.fix_hit_dice = function(weapon) {
          weapon.hit_dice = "1d20+" + weapon.attack_bonus;
          return console.log(weapon.hit_dice);
        };
      }
    };
  }).controller('MainController', [
    '$scope', '$timeout', function($scope, $timeout) {
      var entity_counter;
      $scope.entities = [];
      $scope.results = [];
      $scope.ruleset = "d&d";
      $scope.attack_options = {};
      $scope.saved_checks = [];
      $scope.current_check = {};
      entity_counter = 0;
      $scope.angular = angular;
      $scope.save = function() {
        var blob;
        blob = new Blob([angular.toJson($scope.entities)], {
          type: "application/json;charset=utf-8"
        });
        return saveAs(blob, "rpg.json");
      };
      $scope.load = function() {
        $("#load_file").trigger("click");
      };
      $("#load_file").on("change", function() {
        var file, reader;
        file = this.files[0];
        if (!file) {
          return;
        }
        reader = new FileReader();
        reader.readAsText(file, "UTF-8");
        reader.onload = function(evt) {
          var entities;
          entities = JSON.parse(evt.target.result);
          return entities.map(function(e) {
            var ent;
            ent = make_entity(e);
            return $scope.$apply(function(scope) {
              return scope.entities.push(ent);
            });
          });
        };
        return reader.onerror = function(evt) {
          return console.error("error loading file");
        };
      });
      $("#attack_modal").on("shown", function() {
        return setTimeout(function() {
          return $("#attack_modal input[name='custom_roll']").focus();
        }, 1);
      });
      $scope.save_check = function(check) {
        var c, i, _i, _len, _ref;
        _ref = $scope.saved_checks;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          c = _ref[i];
          if (c.name === check.name) {
            $scope.saved_checks[i] = check;
            return;
          }
        }
        return $scope.saved_checks.push(angular.extend({}, check));
      };
      $scope.roll_check = function(check) {
        var check_results, e, res, _i, _len, _ref;
        console.log(check);
        check_results = [];
        _ref = check.entities;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          e = _ref[_i];
          res = roll_dice("1d20+" + (e.checks[check.type] || 0));
          console.log("Rolled ", "1d20+" + (e.checks[check.type] || 0), " and got a ", res);
          check_results.push({
            roll: res,
            name: e.name
          });
        }
        check_results.sort(function(a, b) {
          return a.roll < b.roll;
        });
        return $scope.results.unshift({
          type: "check",
          name: check.name || check.type,
          checks: check_results
        });
      };
      $scope.add_entity = function() {
        var ent;
        ent = make_entity({
          name: "entity" + (entity_counter++)
        });
        $scope.entities.push(ent);
        return $scope.editee = ent;
      };
      $scope.edit_entity = function($event, entity) {
        $event.stopPropagation();
        $scope.editee = entity;
        $scope.clear_attack();
        $("#entity_modal").modal("show");
      };
      $scope.remove_entity = function($event, entity) {
        $event.stopPropagation();
        entity.removing = true;
        return $timeout(function() {
          return delete $scope.entities.splice($scope.entities.indexOf(entity), 1);
        }, 500);
      };
      $scope.get_attack_options = function() {
        switch ($scope.ruleset) {
          case 'd&d':
            return {};
          case 'got':
            return {
              use_degree: true
            };
          default:
            return {};
        }
      };
      $scope.set_combatant = function(entity) {
        if (!$scope.attacker) {
          if (entity.weapons.length && entity.weapons.indexOf(entity.chosen_weapon) === -1) {
            entity.chosen_weapon = entity.weapons[0];
          }
          return $scope.attacker = entity;
        } else {
          $scope.defender = entity;
          if ($scope.attacker.uuid === $scope.defender.uuid) {
            $scope.clear_attack();
            return null;
          }
          $("#attack_modal").modal("show");
        }
      };
      $scope.clear_attack = function() {
        $scope.attacker = null;
        $scope.defender = null;
        return $scope.attack_options = {};
      };
      $scope.do_attack = function() {
        var result;
        angular.extend($scope.attack_options, $scope.get_attack_options());
        result = $scope.attacker.chosen_weapon.attack($scope.defender, $scope.attack_options);
        result.attacker = $scope.attacker;
        result.defender = $scope.defender;
        result.type = 'attack';
        console.log(result);
        $scope.results.unshift(result);
        $("#attack_modal").modal("hide");
        return $scope.clear_attack();
      };
      return $scope.remove_attack = function(result) {
        result.defender.heal(result.given_damage);
        return delete $scope.results.splice($scope.results.indexOf(result), 1);
      };
    }
  ]);

}).call(this);
