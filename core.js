// Generated by CoffeeScript 1.6.3
(function() {
  var Entity, Weapon, app, roll_dice, uuid, _roll_die;

  String.prototype.toTitleCase = function() {
    return this.replace(/\w\S*/g, function(txt) {
      return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
  };

  uuid = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r, v;
      r = Math.random() * 16 | 0;
      v = c === 'x' ? r : r & 0x3 || 0x8;
      return v.toString(16);
    });
  };

  roll_dice = function(roll_string) {
    /*
    Example roll strings:
    1d6
    1d8 + 8
    1d8 + 2d4 + 3
    */

    var dice, dice_parts, roll, roll_part, roll_parts, _i, _len;
    dice_parts = roll_string.split(/\ *\+\ */g);
    roll = 0;
    roll_parts = [];
    for (_i = 0, _len = dice_parts.length; _i < _len; _i++) {
      dice = dice_parts[_i];
      roll_part = _roll_die(dice);
      roll_parts.push("" + dice + " - " + roll_part);
      roll += roll_part;
    }
    console.log("Rolled a " + roll_string + ", parts were " + roll_parts);
    return roll;
  };

  _roll_die = function(dice) {
    var die, i, num, roll, total, _ref;
    if (typeof dice === "int") {
      return dice;
    }
    if (dice.indexOf('d') === -1) {
      return parseInt(dice);
    }
    _ref = dice.split("d"), num = _ref[0], die = _ref[1];
    num = parseInt(num);
    die = parseInt(die);
    i = total = 0;
    while (i < num) {
      roll = Math.ceil(Math.random() * die);
      total += roll;
      i++;
    }
    return total;
  };

  Entity = (function() {
    Entity.default_options = {
      name: "New entity",
      cur_hit_points: 10,
      max_hit_points: 10,
      armor_class: 10,
      armor_reduction: 0,
      weapons: [],
      checks: {}
    };

    function Entity(options) {
      var k, v, _ref;
      if (options == null) {
        options = {};
      }
      _ref = angular.extend({}, Entity.default_options, options);
      for (k in _ref) {
        v = _ref[k];
        this[k] = v;
      }
      this.weapons = this.weapons.map(function(w) {
        if (w.constructor.name === "Weapon") {
          return w;
        } else {
          return new Weapon(w);
        }
      });
      this.uuid = uuid();
    }

    Entity.prototype.damage = function(damage) {
      if (damage == null) {
        damage = 0;
      }
      return this.cur_hit_points -= damage < 0 ? 0 : damage;
    };

    Entity.prototype.heal = function(healing) {
      if (healing == null) {
        healing = 0;
      }
      return this.cur_hit_points += healing < 0 ? 0 : healing;
    };

    return Entity;

  })();

  Weapon = (function() {
    function Weapon(options) {
      var k, v;
      if (options == null) {
        options = {};
      }
      for (k in options) {
        v = options[k];
        this[k] = v;
      }
    }

    Weapon.prototype.attack = function(defender, options) {
      var base_damage, bonus, degree, given_damage, hit, roll;
      if (options == null) {
        options = {};
      }
      if (options.roll) {
        roll = parseInt(options.roll);
        bonus = /\ *[+-]\d(?!n)/.exec(this.hit_dice);
        if (bonus) {
          roll += parseInt(bonus[0]);
        }
      } else {
        roll = roll_dice(this.hit_dice);
      }
      roll += options.hit_modifier || 0;
      hit = roll > defender.armor_class;
      if (!hit) {
        return {
          hit: hit,
          roll: roll
        };
      }
      degree = 1;
      if (options.use_degree) {
        degree = Math.ceil((roll - defender.armor_class) / 5);
      }
      base_damage = roll_dice(this.damage);
      given_damage = (degree * base_damage) - defender.armor_reduction;
      defender.damage(given_damage);
      return {
        hit: hit,
        roll: roll,
        degree: degree,
        base_damage: base_damage,
        given_damage: given_damage
      };
    };

    return Weapon;

  })();

  app = angular.module('app', ['ui.sortable']).factory('debounce', [
    '$timeout', function($timeout) {
      var timer;
      timer = null;
      return function(callback, ms) {
        if (timer) {
          $timeout.cancel(timer);
        }
        return timer = $timeout(callback, ms);
      };
    }
  ]).directive('entity', function() {
    return {
      restrict: "E",
      replace: true,
      scope: false,
      templateUrl: "entity.html",
      controller: function($scope, $element, $attrs) {
        $element.on("click", function(e) {
          if ($(e.toElement).is("a.dropdown-toggle, a > i, a > b, ul.dropdown-menu li, ul.dropdown-menu li > a")) {
            return;
          }
          return $scope.$apply(function(scope) {
            return scope.$root.set_combatant(scope.entity);
          });
        });
        return $scope.hit_point_color = function() {
          var hp;
          hp = $scope.entity.cur_hit_points;
          if (hp < 1) {
            return "red";
          } else if (hp < 0.5 * $scope.entity.max_hit_points) {
            return "yellow";
          }
          return "";
        };
      }
    };
  }).directive('entitybasics', function() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        entity: "="
      },
      templateUrl: "entity_basics.html"
    };
  }).directive('ddentity', function() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        entity: "="
      },
      templateUrl: "ddentity.html",
      controller: function($scope, $element, $attrs) {
        $scope.add_weapon = function() {
          return $scope.entity.weapons.push(new Weapon());
        };
        return $scope.fix_hit_dice = function(weapon) {
          return weapon.hit_dice = "1d20+" + weapon.attack_bonus;
        };
      }
    };
  }).controller('MainController', [
    '$rootScope', '$timeout', function($scope, $timeout) {
      var entity_counter;
      $scope.entities = [
        {
          name: "Players",
          members: []
        }, {
          name: "Enemies",
          members: []
        }, {
          name: "NPCs",
          members: []
        }
      ];
      entity_counter = 0;
      $scope.angular = angular;
      $scope.ruleset = "d&d";
      $scope.check_types = ['listen', 'spot', 'fortitude', 'reflex', 'will'];
      $scope.results = [];
      $scope.attack_options = {};
      $scope.sortableOptions = {
        connectWith: ".entities",
        revert: true,
        delay: 100,
        distance: 10,
        start: function(event, ui) {
          return $(event.toElement).one('click', function(e) {
            return e.stopImmediatePropagation();
          });
        }
      };
      $scope.roll_check = function(check) {
        var check_results, e, res, _i, _len, _ref;
        console.log(check);
        check_results = [];
        _ref = check.entities;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          e = _ref[_i];
          res = roll_dice("1d20+" + (e.checks[check.type] || 0));
          console.log("Rolled ", "1d20+" + (e.checks[check.type] || 0), " and got a ", res);
          check_results.push({
            roll: res,
            name: e.name
          });
        }
        check_results.sort(function(a, b) {
          return a.roll < b.roll;
        });
        return $scope.results.unshift({
          type: "check",
          name: check.name || check.type.toTitleCase(),
          checks: check_results
        });
      };
      $scope.make_entity = function(options) {
        var e;
        if (options == null) {
          options = {};
        }
        e = new Entity(options);
        e.adding = true;
        $timeout(function() {
          return e.adding = false;
        }, 1000);
        return e;
      };
      $scope.get_group = function(group_name) {
        var group, _i, _len, _ref;
        _ref = $scope.entities;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          if (group.name === group_name) {
            return group;
          }
        }
        return null;
      };
      $scope.extend_entities = function(ent_groups) {
        var group, _group, _i, _len;
        for (_i = 0, _len = ent_groups.length; _i < _len; _i++) {
          _group = ent_groups[_i];
          group = $scope.get_group(_group.name);
          if (group) {
            group.members = group.members.concat(_group.members);
          } else {
            $scope.entities.push(_group);
          }
        }
      };
      $scope.add_entity = function(group_name) {
        var ent;
        if (group_name == null) {
          group_name = "Players";
        }
        ent = $scope.make_entity({
          name: "entity" + (entity_counter++)
        });
        $scope.get_group(group_name).members.push(ent);
        return $scope.edit_entity(ent);
      };
      $scope.edit_entity = function($event, entity) {
        if (entity) {
          $event.stopPropagation();
        } else {
          entity = $event;
          $event = null;
        }
        $scope.editee = entity;
        $scope.clear_attack();
        $("#entity_modal").modal("show");
      };
      $scope.copy_entity = function($event, i, ent) {
        var e;
        e = angular.copy(ent);
        e.uuid = null;
        return $scope.entities[i].members.push($scope.make_entity(e));
      };
      $scope.remove_entity = function($event, gi, i, entity) {
        $event.stopPropagation();
        entity.removing = true;
        return $timeout(function() {
          return delete $scope.entities[gi].members.splice(i, 1);
        }, 500);
      };
      $scope.get_attack_options = function() {
        switch ($scope.ruleset) {
          case 'd&d':
            return {};
          case 'got':
            return {
              use_degree: true
            };
          default:
            return {};
        }
      };
      $scope.set_combatant = function(entity) {
        if (!$scope.attacker) {
          if (entity.weapons.length && entity.weapons.indexOf(entity.chosen_weapon) === -1) {
            entity.chosen_weapon = entity.weapons[0];
          }
          return $scope.attacker = entity;
        } else {
          $scope.defender = entity;
          if ($scope.attacker.uuid === $scope.defender.uuid) {
            $scope.clear_attack();
            return null;
          }
          $("#attack_modal").modal("show");
        }
      };
      $scope.clear_attack = function() {
        $scope.attacker = null;
        $scope.defender = null;
        return $scope.attack_options = {};
      };
      $scope.do_attack = function() {
        var result;
        angular.extend($scope.attack_options, $scope.get_attack_options());
        result = $scope.attacker.chosen_weapon.attack($scope.defender, $scope.attack_options);
        result.attacker = $scope.attacker;
        result.defender = $scope.defender;
        result.type = 'attack';
        console.log(result);
        $scope.results.unshift(result);
        $("#attack_modal").modal("hide");
        return $scope.clear_attack();
      };
      $scope.remove_attack = function(result) {
        result.defender.heal(result.given_damage);
        return delete $scope.results.splice($scope.results.indexOf(result), 1);
      };
      $scope.save = function() {
        var blob;
        blob = new Blob([angular.toJson($scope.entities)], {
          type: "application/json;charset=utf-8"
        });
        return saveAs(blob, "rpg.json");
      };
      $scope.load = function() {
        $("#load_file").trigger("click");
      };
      $("#load_file").on("change", function() {
        var file, reader;
        file = this.files[0];
        if (!file) {
          return;
        }
        reader = new FileReader();
        reader.readAsText(file, "UTF-8");
        reader.onload = function(evt) {
          var group, results, _i, _len;
          results = JSON.parse(evt.target.result);
          for (_i = 0, _len = results.length; _i < _len; _i++) {
            group = results[_i];
            group.members = group.members.map(function(e) {
              return new Entity(e);
            });
          }
          return $scope.$apply(function(scope) {
            return scope.extend_entities(results);
          });
        };
        return reader.onerror = function(evt) {
          return console.error("error loading file");
        };
      });
      return $("#attack_modal").on("shown", function() {
        return setTimeout(function() {
          return $("#attack_modal input[name='custom_roll']").focus();
        }, 1);
      });
    }
  ]);

}).call(this);
