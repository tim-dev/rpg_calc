// Generated by CoffeeScript 1.6.3
(function() {
  var Entity, app, make_entity, roll_dice, uuid;

  uuid = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r, v;
      r = Math.random() * 16 | 0;
      v = c === 'x' ? r : r & 0x3 || 0x8;
      return v.toString(16);
    });
  };

  roll_dice = function(dice) {
    var die, i, num, roll, total, _ref;
    if (typeof dice === "int") {
      return dice;
    }
    if (dice.indexOf('d') === -1) {
      return parseInt(dice);
    }
    _ref = dice.split("d"), num = _ref[0], die = _ref[1];
    num = parseInt(num);
    die = parseInt(die);
    i = total = 0;
    while (i < num) {
      roll = Math.ceil(Math.random() * die);
      total += roll;
      i++;
    }
    return total;
  };

  Entity = (function() {
    function Entity(options) {
      var k, v,
        _this = this;
      for (k in options) {
        v = options[k];
        this[k] = v;
      }
      this.name || (this.name = "New entity");
      this.cur_hit_points || (this.cur_hit_points = this.max_hit_points || 10);
      this.max_hit_points || (this.max_hit_points = this.cur_hit_points);
      this.armor_class || (this.armor_class = 10);
      this.armor_reduction || (this.armor_reduction = 0);
      this.weapon_hit_dice || (this.weapon_hit_dice = "1d20");
      this.weapon_damage || (this.weapon_damage = "1d12");
      this.bonus_hit || (this.bonus_hit = 0);
      this.bonus_damage || (this.bonus_damage = 0);
      this.adding = true;
      setTimeout(function() {
        return _this.adding = false;
      }, 1000);
    }

    Entity.prototype.attack = function(defender, options) {
      var base_damage, degree, given_damage, hit, roll;
      if (options == null) {
        options = {};
      }
      roll = options.roll ? options.roll : roll_dice(this.weapon_hit_dice);
      roll += options.hit_modifier || 0;
      hit = roll > defender.armor_class;
      if (!hit) {
        return {
          hit: hit,
          roll: roll
        };
      }
      degree = 1;
      if (options.use_degree) {
        degree = Math.ceil((roll - defender.armor_class) / 5);
      }
      base_damage = roll_dice(this.weapon_damage) + this.bonus_damage;
      given_damage = (degree * base_damage) - defender.armor_reduction;
      defender.damage(given_damage);
      return {
        hit: hit,
        roll: roll,
        degree: degree,
        base_damage: base_damage,
        given_damage: given_damage
      };
    };

    Entity.prototype.damage = function(damage) {
      if (damage == null) {
        damage = 0;
      }
      return this.cur_hit_points -= damage < 0 ? 0 : damage;
    };

    Entity.prototype.heal = function(healing) {
      if (healing == null) {
        healing = 0;
      }
      return this.cur_hit_points += healing < 0 ? 0 : healing;
    };

    return Entity;

  })();

  app = angular.module('app', []);

  app.directive('entity', function() {
    return {
      restrict: "E",
      replace: true,
      scope: {
        entity: "=",
        click: "="
      },
      templateUrl: "entity.html",
      controller: function($scope, $element, $attrs) {
        $($element).draggable();
        return $scope.hit_point_color = function() {
          var hp;
          hp = $scope.entity.cur_hit_points;
          if (hp < 1) {
            return "red";
          } else if (hp < 0.33 * $scope.entity.max_hit_points) {
            return "yellow";
          }
          return "";
        };
      }
    };
  });

  make_entity = function(options) {
    if (options == null) {
      options = {};
    }
    options.uuid = uuid();
    return new Entity(options);
  };

  window.MainController = function($scope, $timeout) {
    var entity_counter;
    $scope.entities = [];
    $scope.results = [];
    $scope.ruleset = "d&d";
    $scope.attack_options = {};
    entity_counter = 0;
    $scope.add_entity = function() {
      var ent;
      ent = make_entity({
        name: "entity" + (entity_counter++)
      });
      $scope.entities.push(ent);
      return $scope.editee = ent;
    };
    $scope.edit_entity = function($event, entity) {
      console.log(entity);
      $event.stopPropagation();
      $scope.editee = entity;
      $scope.clear_attack();
      return $("#entity_modal").modal("show");
    };
    $scope.remove_entity = function($event, entity) {
      $event.stopPropagation();
      entity.removing = true;
      return $timeout(function() {
        return $scope.entities.splice($scope.entities.indexOf(entity), 1);
      }, 1000);
    };
    $scope.get_attack_options = function() {
      switch ($scope.ruleset) {
        case 'd&d':
          return {};
        case 'got':
          return {
            use_degree: true
          };
        default:
          return {};
      }
    };
    $scope.set_combatant = function(entity) {
      if (!$scope.attacker) {
        return $scope.attacker = entity;
      } else {
        $scope.defender = entity;
        if ($scope.attacker.uuid === $scope.defender.uuid) {
          $scope.clear_attack();
          return null;
        }
        return $("#attack_modal").modal("show");
      }
    };
    $scope.clear_attack = function() {
      $scope.attacker = null;
      $scope.defender = null;
      return $scope.attack_options = {};
    };
    $scope.do_attack = function() {
      var result;
      angular.extend($scope.attack_options, $scope.get_attack_options());
      result = $scope.attacker.attack($scope.defender, $scope.attack_options);
      result.attacker = $scope.attacker;
      result.defender = $scope.defender;
      console.log(result);
      $scope.results.push(result);
      return $scope.clear_attack();
    };
    return $scope.remove_attack = function(result) {
      result.defender.heal(result.given_damage);
      return $scope.results.splice($scope.results.indexOf(result), 1);
    };
  };

}).call(this);
